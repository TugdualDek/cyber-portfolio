---
title: "Comment cr√©er un scanneur de vuln√©rabilit√©s web : de l'id√©e √† l'architecture distribu√©e"
date: "2025-06-12"
executionDate: "2025-01-10"
excerpt: "Retour d'exp√©rience sur le d√©veloppement d'un scanneur de vuln√©rabilit√©s web avec une architecture distribu√©e Redis. Un projet √©tudiant qui m√™le th√©orie accessible et pratique technique."
classification: "RESTRICTED"
category: "Cybersecurity"
caseNumber: "FR-VULN-SCANNER-2025-001"
language: "fr"
coverImage: "/assets/blog/scanneur/architecture.webp"
---

_"La cybers√©curit√© ressemble √† une partie d'√©checs sans fin : pour chaque attaque, une d√©fense doit √™tre trouv√©e."_

Dans le cadre de notre cours de s√©curit√© logicielle, nous avons d√©velopp√© en √©quipe de 6 personnes un scanneur de vuln√©rabilit√©s pour applications web. Ce projet n'a pas la pr√©tention d'√™tre r√©volutionnaire, mais notre d√©marche et les d√©fis techniques surmont√©s pourraient int√©resser ceux qui veulent comprendre comment automatiser la s√©curit√© web.

# üõ°Ô∏è Les vuln√©rabilit√©s web expliqu√©es simplement

## Le probl√®me : des failles partout

Votre site web, c'est comme une maison avec des dizaines de portes et fen√™tres. Une vuln√©rabilit√©, c'est une serrure d√©fectueuse qui permet √† un intrus d'entrer. Le souci ? Un site moderne peut avoir **des centaines de points d'entr√©e** √† v√©rifier.

<Callout type="saviez-vous">
**L'OWASP Top 10 : le guide de r√©f√©rence**

L'OWASP est une communaut√© mondiale qui publie chaque ann√©e le "Top 10" des vuln√©rabilit√©s web les plus dangereuses. C'est la r√©f√©rence internationale que tout d√©veloppeur devrait conna√Ætre pour s√©curiser ses applications.

</Callout>

**Les 3 failles les plus courantes :**

üîπ **Injection SQL** : Un attaquant peut "parler" directement √† votre base de donn√©es  
üîπ **Authentification cass√©e** : Les mots de passe ou sessions mal prot√©g√©s  
üîπ **Donn√©es expos√©es** : Des informations sensibles visibles par tous

**Pourquoi automatiser ?** Tester manuellement des centaines de param√®tres prendrait des semaines. De nouvelles vuln√©rabilit√©s apparaissent chaque jour. M√™me les experts peuvent oublier un d√©tail.

# ‚öôÔ∏è Notre solution : de l'id√©e simple √† l'architecture complexe

## L'inspiration : "l'Ansible des attaques"

Au d√©but, on voulait cr√©er des "recettes d'attaques" automatiques. Comme Ansible automatise la configuration de serveurs, on voulait automatiser les tests de s√©curit√© avec des fichiers YAML simples.

<Callout type="saviez-vous">
**Qu'est-ce qu'Ansible ?**

Ansible est un outil qui automatise la gestion d'infrastructures. Il lit des "recettes" √©crites en YAML pour configurer des serveurs.

Notre id√©e : appliquer ce concept aux tests de s√©curit√©.

</Callout>

**Le probl√®me qu'on a vite d√©couvert :** Les tests de s√©curit√© peuvent durer un certains temps en fonction de leur impl√©mentation.

Comment permettre plusieurs scans simultan√©s sans planter l'interface ?

## Notre architecture distribu√©e

**La solution :** S√©parer l'interface utilisateur de l'ex√©cution des tests avec une architecture distribu√©e.

<TechnicalImage
  src="/assets/blog/scanneur/architecture2.webp"
  alt="Architecture g√©n√©rale de notre solution"
  caption="Architecture g√©n√©rale de notre solution"
/>

<TechnicalImage
  src="/assets/blog/scanneur/architecture.webp"
  alt="Sch√©ma de notre architecture distribu√©e"
  caption="Architecture de notre scanneur : interface React, API Flask, Redis et workers Python"
/>

**Les 4 composants cl√©s :**

1. **Interface React** : Pour configurer et suivre les scans en temps r√©el
2. **API Flask** : Le chef d'orchestre qui coordonne tout
3. **Redis** : La file d'attente ultra-rapide qui stocke les t√¢ches
4. **Workers Python** : Les "ouvriers" qui ex√©cutent les tests en parall√®le

<Callout type="saviez-vous">
**Pourquoi Redis comme file d'attente ?**

Redis est une base de donn√©es en m√©moire ultra-rapide. Pour notre usage, c'est comme un tableau d'affichage digital : les t√¢ches y sont post√©es instantan√©ment et les workers les r√©cup√®rent √† la vitesse de l'√©clair. Parfait pour coordonner des processus distribu√©s.

</Callout>

## Le syst√®me modulaire : la magie du YAML

**L'id√©e :** Chaque test de s√©curit√© est d√©compos√© en "modules" r√©utilisables, orchestr√©s par des fichiers YAML.

```yaml
name: test_securite_complete
description: Analyse compl√®te des vuln√©rabilit√©s web
steps:
  - module: http_request
    params:
      url: "{{ target }}"
      timeout: 10
  - module: analyze_headers
  - module: test_sql_injection
  - module: test_xss
```

L'avantage : N'importe qui peut cr√©er un nouveau test sans programmer !

<TechnicalImage
  src="/assets/blog/scanneur/gui.webp"
  alt="Interface utilisateur du scanneur"
  caption="Interface d'accueil de notre scanneur"
/>

<TechnicalImage
  src="/assets/blog/scanneur/results.webp"
  alt="Exemple de r√©sultat du scanneur"
  caption="Exemple de r√©sultat du scanneur"
/>

# üîç Exemple concret : d√©tecter une faille XSS

<Callout type="saviez-vous">
**Qu'est-ce qu'une faille XSS ?**

XSS (Cross-Site Scripting) permet d'injecter du code malveillant dans une page web. C'est comme coller un post-it pi√©g√© qui s'activerait sur l'√©cran de chaque visiteur : vol de donn√©es, redirections malveillantes, etc.

</Callout>

**Notre approche :** Le scanneur teste automatiquement diff√©rents "payloads" malveillants pour voir si le site les filtre correctement.

```yaml
name: detection_xss
description: Test automatis√© de vuln√©rabilit√©s XSS
steps:
  - module: http_request
    params:
      url: "{{ target }}"
  - module: xss_tester
    params:
      payloads:
        - "<script>alert('Faille d√©tect√©e!')</script>"
        - '''"><img src=x onerror=alert(''XSS'')>'
```

**Le processus :**

1. Requ√™te HTTP normale vers la cible
2. Test de diff√©rents codes malveillants
3. Analyse de la r√©ponse : le site a-t-il ex√©cut√© notre code ?
4. Rapport automatique avec niveau de risque

# üöß Les 3 d√©fis techniques majeurs

## 1. La synchronisation distribu√©e

**Le d√©fi :** Comment coordonner plusieurs workers sans qu'ils se marchent dessus ?

**Notre solution :** Redis g√®re la file d'attente. Chaque worker prend une t√¢che, la traite, renvoie le r√©sultat. Simple et efficace.

## 2. Le syst√®me de contexte partag√©

**Le d√©fi :** Comment partager des infos entre les diff√©rents modules d'un test ?

**Notre solution :** Un "contexte" (dictionnaire Python) qui voyage de module en module, s'enrichissant √† chaque √©tape.

```python
# Exemple : un module enrichit le contexte
def run(self, context):
    response = requests.get(context['url'])
    context['response_headers'] = response.headers
    context['response_time'] = response.elapsed.total_seconds()
    return context
```

## 3. L'interface utilisateur

**Le d√©fi :** Pr√©senter des r√©sultats techniques de fa√ßon compr√©hensible.

**Notre apprentissage :** Un bon outil de s√©curit√© doit √™tre accessible aux non-experts. Nous ne sommes pas tr√®s bon en design, nous avons essay√© de pr√©senter nos r√©sultats de fa√ßon clair (peut etre trop simplement)

<Callout type="attention">
  La technique ne suffit pas. Si votre outil n'est pas utilisable par les
  √©quipes qui en ont besoin, m√™me le meilleur code ne sert √† rien.
  L'accessibilit√© est aussi importante que la performance.
</Callout>

# ü§ù √âthique et responsabilit√©

<Callout type="attention">
**Usage √©thique uniquement !**

Notre projet inclut des disclaimers clairs :
usage √©ducatif et tests autoris√©s uniquement. En cybers√©curit√©, la fronti√®re
entre recherche l√©gitime et activit√© malveillante est mince. Il faut toujours
agir dans un cadre l√©gal et √©thique.

</Callout>

# Pour conclure

Ce projet n'est pas parfait, mais il nous a √©norm√©ment appris sur la s√©curit√© web moderne et les architectures distribu√©es.

Et vous avez-vous d√©j√† d√©velopp√© des outils de s√©curit√© ? Quelles fonctionnalit√©s consid√©reriez-vous comme prioritaires ?

---

Le code source est disponible √† cette adresse : https://github.com/TugdualDek/projet-secu-logicielle
